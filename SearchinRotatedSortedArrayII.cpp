#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:

	int monotonicity(vector<int>& v,int b,int e) {
		int bv = v[b];
		int ev = v[e];
		int mid = b + (e-b)/2;
		int mv = v[mid];
		if((bv == ev == mv) && (e - b) > 2) {
			if(e-b == 1) return 1;
			int lb = b;
			int le = mid-1 > lb ? mid-1:lb; 
			int ml = monotonicity(v,lb,le);

            int re = e;
           	int rb = mid+1 < re ? mid + 1: re;	
           	int mr = monotonicity(v,rb,re);

           	if(ml == mr) return ml;
           	else return 0;

		} else {
			if(bv <= mv && mv <= ev) return  1;  //递增
			if(bv >= mv && mv >= ev) return -1;  //递减
			return 0;//不确定
		}
	}

    bool search(vector<int>& nums, int target) {
        if(nums.size()==0) return false;
        
        int start=0,end=nums.size()-1;
        
        while(start+1<end){
            int mid=start+(end-start)/2;
            
            if(target==nums[mid]) return true;

            int lb = start;
           	int le = mid-1 > lb ? mid-1:lb;

           	int monotonicityL = monotonicity(nums,lb,le);
           	//确定左半边单调性
           	if(monotonicityL > 0) {
           		//左边递增
	           	if(target >= nums[lb] && target <= nums[le]) {
	           		end = le;
	           		continue;
	           	}           		
           	} else if(monotonicityL < 0) {
           		//左边递减
           		if(target >= nums[le] && target <= nums[lb]) {
           			end = le;
           			continue;
           		}           		
           	}

            int re = end;
           	int rb = mid+1 < re ? mid + 1: re;          	

			int monotonicityR = monotonicity(nums,rb,re);

           	if(monotonicityR > 0) {
           		//右边递增
           		if(target >= nums[rb] && target <= nums[re]) {
           			start = rb;
           			continue;
           		}
           	} else if(monotonicityR < 0) {
           		//右边递减
           		if(target >= nums[re] && target <= nums[rb]) {
           			start = rb;
           			continue;
           		}
           	}

           	if(monotonicityL == 0 || monotonicityR == 0) {
           		//不可能存在两个区间同时无法确定单调性的情况
           		if(monotonicityL == 0) {
           			end = le;
           			continue;
           		} else {
           			start = rb;
           		}

           	} else {
           		return false;
           	}

        }

        if(nums[start]==target) return true;
        else if(nums[end]==target) return true;
        else return false;
		
    }
};

int main() {
	Solution s;
	//vector<int> v{0,0,1,1,2,0};//1 2 0 0 0 0 1 1
	vector<int> v{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
	cout << s.search(v,2) << endl;
}